{"ast":null,"code":"'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport useTimeout from '@mui/utils/useTimeout';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport * as platform from '@mui/x-internals/platform';\nimport { useRunOnce } from '@mui/x-internals/useRunOnce';\nimport { useFirstRender } from '@mui/x-internals/useFirstRender';\nimport { createSelector, useStore, useStoreEffect } from '@mui/x-internals/store';\nimport { PinnedRows, PinnedColumns } from \"../models/core.js\";\nimport { Dimensions } from \"./dimensions.js\";\nimport { ScrollDirection } from \"../models/index.js\";\n\n/* eslint-disable import/export, @typescript-eslint/no-redeclare */\n\nconst clamp = (value, min, max) => Math.max(min, Math.min(max, value));\nconst MINIMUM_COLUMN_WIDTH = 50;\nconst EMPTY_SCROLL_POSITION = {\n  top: 0,\n  left: 0\n};\nconst EMPTY_DETAIL_PANELS = Object.freeze(new Map());\nexport const EMPTY_RENDER_CONTEXT = {\n  firstRowIndex: 0,\n  lastRowIndex: 0,\n  firstColumnIndex: 0,\n  lastColumnIndex: 0\n};\nconst selectors = {\n  renderContext: createSelector(state => state.virtualization.renderContext),\n  enabledForRows: createSelector(state => state.virtualization.enabledForRows),\n  enabledForColumns: createSelector(state => state.virtualization.enabledForColumns)\n};\nexport const Virtualization = {\n  initialize: initializeState,\n  use: useVirtualization,\n  selectors\n};\nfunction initializeState(params) {\n  const state = {\n    virtualization: _extends({\n      enabled: !platform.isJSDOM,\n      enabledForRows: !platform.isJSDOM,\n      enabledForColumns: !platform.isJSDOM,\n      renderContext: EMPTY_RENDER_CONTEXT\n    }, params.initialState?.virtualization),\n    // FIXME: refactor once the state shape is settled\n    getters: null\n  };\n  return state;\n}\n\n/** APIs to override for colspan/rowspan */\n\nfunction useVirtualization(store, params, api) {\n  const {\n    refs,\n    dimensions: {\n      rowHeight,\n      columnsTotalWidth\n    },\n    virtualization: {\n      isRtl = false,\n      rowBufferPx = 150,\n      columnBufferPx = 150\n    },\n    colspan,\n    initialState,\n    rows,\n    range,\n    columns,\n    pinnedRows = PinnedRows.EMPTY,\n    pinnedColumns = PinnedColumns.EMPTY,\n    minimalContentHeight,\n    autoHeight,\n    onWheel,\n    onTouchMove,\n    onRenderContextChange,\n    onScrollChange,\n    scrollReset,\n    renderRow,\n    renderInfiniteLoadingTrigger\n  } = params;\n  const needsHorizontalScrollbar = useStore(store, Dimensions.selectors.needsHorizontalScrollbar);\n  const hasBottomPinnedRows = pinnedRows.bottom.length > 0;\n  const [panels, setPanels] = React.useState(EMPTY_DETAIL_PANELS);\n  const [, setRefTick] = React.useState(0);\n  const isRenderContextReady = React.useRef(false);\n  const renderContext = useStore(store, selectors.renderContext);\n  const enabledForRows = useStore(store, selectors.enabledForRows);\n  const enabledForColumns = useStore(store, selectors.enabledForColumns);\n  const rowsMeta = useStore(store, Dimensions.selectors.rowsMeta);\n  const contentHeight = useStore(store, Dimensions.selectors.contentHeight);\n\n  /*\n   * Scroll context logic\n   * ====================\n   * We only render the cells contained in the `renderContext`. However, when the user starts scrolling the grid\n   * in a direction, we want to render as many cells as possible in that direction, as to avoid presenting white\n   * areas if the user scrolls too fast/far and the viewport ends up in a region we haven't rendered yet. To render\n   * more cells, we store some offsets to add to the viewport in `scrollCache.buffer`. Those offsets make the render\n   * context wider in the direction the user is going, but also makes the buffer around the viewport `0` for the\n   * dimension (horizontal or vertical) in which the user is not scrolling. So if the normal viewport is 8 columns\n   * wide, with a 1 column buffer (10 columns total), then we want it to be exactly 8 columns wide during vertical\n   * scroll.\n   * However, we don't want the rows in the old context to re-render from e.g. 10 columns to 8 columns, because that's\n   * work that's not necessary. Thus we store the context at the start of the scroll in `frozenContext`, and the rows\n   * that are part of this old context will keep their same render context as to avoid re-rendering.\n   */\n  const scrollPosition = React.useRef(initialState?.scroll ?? EMPTY_SCROLL_POSITION);\n  const ignoreNextScrollEvent = React.useRef(false);\n  const previousContextScrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousRowContext = React.useRef(EMPTY_RENDER_CONTEXT);\n  const scrollTimeout = useTimeout();\n  const frozenContext = React.useRef(undefined);\n  const scrollCache = useLazyRef(() => createScrollCache(isRtl, rowBufferPx, columnBufferPx, rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6)).current;\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    if (!areRenderContextsEqual(nextRenderContext, store.state.virtualization.renderContext)) {\n      store.set('virtualization', _extends({}, store.state.virtualization, {\n        renderContext: nextRenderContext\n      }));\n    }\n\n    // The lazy-loading hook is listening to `renderedRowsIntervalChange`,\n    // but only does something if we already have a render context, because\n    // otherwise we would call an update directly on mount\n    const isReady = Dimensions.selectors.dimensions(store.state).isReady;\n    const didRowsIntervalChange = nextRenderContext.firstRowIndex !== previousRowContext.current.firstRowIndex || nextRenderContext.lastRowIndex !== previousRowContext.current.lastRowIndex;\n    if (isReady && didRowsIntervalChange) {\n      previousRowContext.current = nextRenderContext;\n      onRenderContextChange?.(nextRenderContext);\n    }\n    previousContextScrollPosition.current = scrollPosition.current;\n  }, [store, onRenderContextChange]);\n  const triggerUpdateRenderContext = useEventCallback(() => {\n    const scroller = refs.scroller.current;\n    if (!scroller) {\n      return undefined;\n    }\n    const dimensions = Dimensions.selectors.dimensions(store.state);\n    const maxScrollTop = Math.ceil(dimensions.minimumSize.height - dimensions.viewportOuterSize.height);\n    const maxScrollLeft = Math.ceil(dimensions.minimumSize.width - dimensions.viewportInnerSize.width);\n\n    // Clamp the scroll position to the viewport to avoid re-calculating the render context for scroll bounce\n    const newScroll = {\n      top: clamp(scroller.scrollTop, 0, maxScrollTop),\n      left: isRtl ? clamp(scroller.scrollLeft, -maxScrollLeft, 0) : clamp(scroller.scrollLeft, 0, maxScrollLeft)\n    };\n    const dx = newScroll.left - scrollPosition.current.left;\n    const dy = newScroll.top - scrollPosition.current.top;\n    const isScrolling = dx !== 0 || dy !== 0;\n    scrollPosition.current = newScroll;\n    const direction = isScrolling ? ScrollDirection.forDelta(dx, dy) : ScrollDirection.NONE;\n\n    // Since previous render, we have scrolled...\n    const rowScroll = Math.abs(scrollPosition.current.top - previousContextScrollPosition.current.top);\n    const columnScroll = Math.abs(scrollPosition.current.left - previousContextScrollPosition.current.left);\n\n    // PERF: use the computed minimum column width instead of a static one\n    const didCrossThreshold = rowScroll >= rowHeight || columnScroll >= MINIMUM_COLUMN_WIDTH;\n    const didChangeDirection = scrollCache.direction !== direction;\n    const shouldUpdate = didCrossThreshold || didChangeDirection;\n    if (!shouldUpdate) {\n      return renderContext;\n    }\n\n    // Render a new context\n\n    if (didChangeDirection) {\n      switch (direction) {\n        case ScrollDirection.NONE:\n        case ScrollDirection.LEFT:\n        case ScrollDirection.RIGHT:\n          frozenContext.current = undefined;\n          break;\n        default:\n          frozenContext.current = renderContext;\n          break;\n      }\n    }\n    scrollCache.direction = direction;\n    scrollCache.buffer = bufferForDirection(isRtl, direction, rowBufferPx, columnBufferPx, rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6);\n    const inputs = inputsSelector(store, params, api, enabledForRows, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    if (!areRenderContextsEqual(nextRenderContext, renderContext)) {\n      // Prevents batching render context changes\n      ReactDOM.flushSync(() => {\n        updateRenderContext(nextRenderContext);\n      });\n      scrollTimeout.start(1000, triggerUpdateRenderContext);\n    }\n    return nextRenderContext;\n  });\n  const forceUpdateRenderContext = useEventCallback(() => {\n    // skip update if dimensions are not ready and virtualization is enabled\n    if (!Dimensions.selectors.dimensions(store.state).isReady && (enabledForRows || enabledForColumns)) {\n      return;\n    }\n    const inputs = inputsSelector(store, params, api, enabledForRows, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    // Reset the frozen context when the render context changes, see the illustration in https://github.com/mui/mui-x/pull/12353\n    frozenContext.current = undefined;\n    updateRenderContext(nextRenderContext);\n  });\n  const handleScroll = useEventCallback(() => {\n    if (ignoreNextScrollEvent.current) {\n      ignoreNextScrollEvent.current = false;\n      return;\n    }\n    const nextRenderContext = triggerUpdateRenderContext();\n    if (nextRenderContext) {\n      onScrollChange?.(scrollPosition.current, nextRenderContext);\n    }\n  });\n  const getOffsetTop = () => {\n    return rowsMeta.positions[renderContext.firstRowIndex] ?? 0;\n  };\n\n  /**\n   * HACK: unstable_rowTree fixes the issue described below, but does it by tightly coupling this\n   * section of code to the DataGrid's rowTree model. The `unstable_rowTree` param is a temporary\n   * solution to decouple the code.\n   */\n  const getRows = (rowParams = {}, unstable_rowTree) => {\n    if (!rowParams.rows && !range) {\n      return [];\n    }\n    let baseRenderContext = renderContext;\n    if (rowParams.renderContext) {\n      baseRenderContext = rowParams.renderContext;\n      baseRenderContext.firstColumnIndex = renderContext.firstColumnIndex;\n      baseRenderContext.lastColumnIndex = renderContext.lastColumnIndex;\n    }\n    const isLastSection = !hasBottomPinnedRows && rowParams.position === undefined || hasBottomPinnedRows && rowParams.position === 'bottom';\n    const isPinnedSection = rowParams.position !== undefined;\n    let rowIndexOffset;\n    switch (rowParams.position) {\n      case 'top':\n        rowIndexOffset = 0;\n        break;\n      case 'bottom':\n        rowIndexOffset = pinnedRows.top.length + rows.length;\n        break;\n      case undefined:\n      default:\n        rowIndexOffset = pinnedRows.top.length;\n        break;\n    }\n    const rowModels = rowParams.rows ?? rows;\n    const firstRowToRender = baseRenderContext.firstRowIndex;\n    const lastRowToRender = Math.min(baseRenderContext.lastRowIndex, rowModels.length);\n    const rowIndexes = rowParams.rows ? createRange(0, rowParams.rows.length) : createRange(firstRowToRender, lastRowToRender);\n    let virtualRowIndex = -1;\n    const focusedVirtualCell = params.focusedVirtualCell?.();\n    if (!isPinnedSection && focusedVirtualCell) {\n      if (focusedVirtualCell.rowIndex < firstRowToRender) {\n        rowIndexes.unshift(focusedVirtualCell.rowIndex);\n        virtualRowIndex = focusedVirtualCell.rowIndex;\n      }\n      if (focusedVirtualCell.rowIndex > lastRowToRender) {\n        rowIndexes.push(focusedVirtualCell.rowIndex);\n        virtualRowIndex = focusedVirtualCell.rowIndex;\n      }\n    }\n    const rowElements = [];\n    const columnPositions = Dimensions.selectors.columnPositions(store.state, columns);\n    rowIndexes.forEach(rowIndexInPage => {\n      const {\n        id,\n        model\n      } = rowModels[rowIndexInPage];\n\n      // In certain cases, the state might already be updated and `params.rows` (which sets `rowModels`)\n      // contains stale data.\n      // In that case, skip any further row processing.\n      // See:\n      // - https://github.com/mui/mui-x/issues/16638\n      // - https://github.com/mui/mui-x/issues/17022\n      if (unstable_rowTree && !unstable_rowTree[id]) {\n        return;\n      }\n      const rowIndex = (range?.firstRowIndex || 0) + rowIndexOffset + rowIndexInPage;\n\n      // NOTE: This is an expensive feature, the colSpan code could be optimized.\n      if (colspan?.enabled) {\n        const minFirstColumn = pinnedColumns.left.length;\n        const maxLastColumn = columns.length - pinnedColumns.right.length;\n        api.calculateColSpan(id, minFirstColumn, maxLastColumn, columns);\n        if (pinnedColumns.left.length > 0) {\n          api.calculateColSpan(id, 0, pinnedColumns.left.length, columns);\n        }\n        if (pinnedColumns.right.length > 0) {\n          api.calculateColSpan(id, columns.length - pinnedColumns.right.length, columns.length, columns);\n        }\n      }\n      const baseRowHeight = !api.rowsMeta.rowHasAutoHeight(id) ? api.rowsMeta.getRowHeight(id) : 'auto';\n      let isFirstVisible = false;\n      if (rowParams.position === undefined) {\n        isFirstVisible = rowIndexInPage === 0;\n      }\n      let isLastVisible = false;\n      const isLastVisibleInSection = rowIndexInPage === rowModels.length - 1;\n      if (isLastSection) {\n        if (!isPinnedSection) {\n          const lastIndex = rows.length - 1;\n          const isLastVisibleRowIndex = rowIndexInPage === lastIndex;\n          if (isLastVisibleRowIndex) {\n            isLastVisible = true;\n          }\n        } else {\n          isLastVisible = isLastVisibleInSection;\n        }\n      }\n      let currentRenderContext = baseRenderContext;\n      if (frozenContext.current && rowIndexInPage >= frozenContext.current.firstRowIndex && rowIndexInPage < frozenContext.current.lastRowIndex) {\n        currentRenderContext = frozenContext.current;\n      }\n      const isVirtualFocusRow = rowIndexInPage === virtualRowIndex;\n      const isVirtualFocusColumn = focusedVirtualCell?.rowIndex === rowIndex;\n      const offsetLeft = computeOffsetLeft(columnPositions, currentRenderContext, pinnedColumns.left.length);\n      const showBottomBorder = isLastVisibleInSection && rowParams.position === 'top';\n      const firstColumnIndex = currentRenderContext.firstColumnIndex;\n      const lastColumnIndex = currentRenderContext.lastColumnIndex;\n      rowElements.push(renderRow({\n        id,\n        model,\n        rowIndex,\n        offsetLeft,\n        columnsTotalWidth,\n        baseRowHeight,\n        firstColumnIndex,\n        lastColumnIndex,\n        focusedColumnIndex: isVirtualFocusColumn ? focusedVirtualCell.columnIndex : undefined,\n        isFirstVisible,\n        isLastVisible,\n        isVirtualFocusRow,\n        showBottomBorder\n      }));\n      if (isVirtualFocusRow) {\n        return;\n      }\n      const panel = panels.get(id);\n      if (panel) {\n        rowElements.push(panel);\n      }\n      if (rowParams.position === undefined && isLastVisibleInSection) {\n        rowElements.push(renderInfiniteLoadingTrigger(id));\n      }\n    });\n    return rowElements;\n  };\n  const scrollerStyle = React.useMemo(() => ({\n    overflowX: !needsHorizontalScrollbar ? 'hidden' : undefined,\n    overflowY: autoHeight ? 'hidden' : undefined\n  }), [needsHorizontalScrollbar, autoHeight]);\n  const contentSize = React.useMemo(() => {\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      flexBasis: contentHeight,\n      flexShrink: 0\n    };\n    if (size.flexBasis === 0) {\n      size.flexBasis = minimalContentHeight; // Give room to show the overlay when there no rows.\n    }\n    return size;\n  }, [columnsTotalWidth, contentHeight, needsHorizontalScrollbar, minimalContentHeight]);\n  const scrollRestoreCallback = React.useRef(null);\n  const contentNodeRef = React.useCallback(node => {\n    if (!node) {\n      return;\n    }\n    scrollRestoreCallback.current?.(columnsTotalWidth, contentHeight);\n  }, [columnsTotalWidth, contentHeight]);\n  useEnhancedEffect(() => {\n    if (!isRenderContextReady.current) {\n      return;\n    }\n    forceUpdateRenderContext();\n  }, [enabledForColumns, enabledForRows, forceUpdateRenderContext]);\n  useEnhancedEffect(() => {\n    if (refs.scroller.current) {\n      refs.scroller.current.scrollLeft = 0;\n    }\n  }, [refs.scroller, scrollReset]);\n  useRunOnce(renderContext !== EMPTY_RENDER_CONTEXT, () => {\n    onScrollChange?.(scrollPosition.current, renderContext);\n    isRenderContextReady.current = true;\n    if (initialState?.scroll && refs.scroller.current) {\n      const scroller = refs.scroller.current;\n      const {\n        top,\n        left\n      } = initialState.scroll;\n      const isScrollRestored = {\n        top: !(top > 0),\n        left: !(left > 0)\n      };\n      if (!isScrollRestored.left && columnsTotalWidth) {\n        scroller.scrollLeft = left;\n        isScrollRestored.left = true;\n        ignoreNextScrollEvent.current = true;\n      }\n\n      // To restore the vertical scroll, we need to wait until the rows are available in the DOM (otherwise\n      // there's nowhere to scroll). We still set the scrollTop to the initial value at this point in case\n      // there already are rows rendered in the DOM, but we only confirm `isScrollRestored.top = true` in the\n      // asynchronous callback below.\n      if (!isScrollRestored.top && contentHeight) {\n        scroller.scrollTop = top;\n        ignoreNextScrollEvent.current = true;\n      }\n      if (!isScrollRestored.top || !isScrollRestored.left) {\n        scrollRestoreCallback.current = (columnsTotalWidthCurrent, contentHeightCurrent) => {\n          if (!isScrollRestored.left && columnsTotalWidthCurrent) {\n            scroller.scrollLeft = left;\n            isScrollRestored.left = true;\n            ignoreNextScrollEvent.current = true;\n          }\n          if (!isScrollRestored.top && contentHeightCurrent) {\n            scroller.scrollTop = top;\n            isScrollRestored.top = true;\n            ignoreNextScrollEvent.current = true;\n          }\n          if (isScrollRestored.left && isScrollRestored.top) {\n            scrollRestoreCallback.current = null;\n          }\n        };\n      }\n    }\n  });\n  useStoreEffect(store, Dimensions.selectors.dimensions, forceUpdateRenderContext);\n  const refSetter = name => node => {\n    if (node && refs[name].current !== node) {\n      refs[name].current = node;\n      setRefTick(tick => tick + 1);\n    }\n  };\n  const getters = {\n    setPanels,\n    getOffsetTop,\n    getRows,\n    getContainerProps: () => ({\n      ref: refSetter('container')\n    }),\n    getScrollerProps: () => ({\n      ref: refSetter('scroller'),\n      onScroll: handleScroll,\n      onWheel,\n      onTouchMove,\n      style: scrollerStyle,\n      role: 'presentation',\n      // `tabIndex` shouldn't be used along role=presentation, but it fixes a Firefox bug\n      // https://github.com/mui/mui-x/pull/13891#discussion_r1683416024\n      tabIndex: platform.isFirefox ? -1 : undefined\n    }),\n    getContentProps: () => ({\n      ref: contentNodeRef,\n      style: contentSize,\n      role: 'presentation'\n    }),\n    getScrollbarVerticalProps: () => ({\n      ref: refSetter('scrollbarVertical'),\n      scrollPosition\n    }),\n    getScrollbarHorizontalProps: () => ({\n      ref: refSetter('scrollbarHorizontal'),\n      scrollPosition\n    }),\n    getScrollAreaProps: () => ({\n      scrollPosition\n    })\n  };\n  useFirstRender(() => {\n    store.state = _extends({}, store.state, {\n      getters\n    });\n  });\n  React.useEffect(() => {\n    store.update({\n      getters\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, Object.values(getters));\n\n  /* Placeholder API functions for colspan & rowspan to re-implement */\n\n  const getCellColSpanInfo = () => {\n    throw new Error('Unimplemented: colspan feature is required');\n  };\n  const calculateColSpan = () => {\n    throw new Error('Unimplemented: colspan feature is required');\n  };\n  const getHiddenCellsOrigin = () => {\n    throw new Error('Unimplemented: rowspan feature is required');\n  };\n  return {\n    getters,\n    useVirtualization: () => useStore(store, state => state),\n    setPanels,\n    forceUpdateRenderContext,\n    getCellColSpanInfo,\n    calculateColSpan,\n    getHiddenCellsOrigin\n  };\n}\nfunction inputsSelector(store, params, api, enabledForRows, enabledForColumns) {\n  const dimensions = Dimensions.selectors.dimensions(store.state);\n  const rows = params.rows;\n  const range = params.range;\n  const columns = params.columns;\n  const hiddenCellsOriginMap = api.getHiddenCellsOrigin();\n  const lastRowId = params.rows.at(-1)?.id;\n  const lastColumn = columns.at(-1);\n  return {\n    api,\n    enabledForRows,\n    enabledForColumns,\n    autoHeight: params.autoHeight,\n    rowBufferPx: params.virtualization.rowBufferPx,\n    columnBufferPx: params.virtualization.columnBufferPx,\n    leftPinnedWidth: dimensions.leftPinnedWidth,\n    columnsTotalWidth: dimensions.columnsTotalWidth,\n    viewportInnerWidth: dimensions.viewportInnerSize.width,\n    viewportInnerHeight: dimensions.viewportInnerSize.height,\n    lastRowHeight: lastRowId !== undefined ? api.rowsMeta.getRowHeight(lastRowId) : 0,\n    lastColumnWidth: lastColumn?.computedWidth ?? 0,\n    rowsMeta: Dimensions.selectors.rowsMeta(store.state),\n    columnPositions: Dimensions.selectors.columnPositions(store.state, params.columns),\n    rows,\n    range,\n    pinnedColumns: params.pinnedColumns,\n    columns,\n    hiddenCellsOriginMap,\n    virtualizeColumnsWithAutoRowHeight: params.virtualizeColumnsWithAutoRowHeight\n  };\n}\nfunction computeRenderContext(inputs, scrollPosition, scrollCache) {\n  const renderContext = {\n    firstRowIndex: 0,\n    lastRowIndex: inputs.rows.length,\n    firstColumnIndex: 0,\n    lastColumnIndex: inputs.columns.length\n  };\n  const {\n    top,\n    left\n  } = scrollPosition;\n  const realLeft = Math.abs(left) + inputs.leftPinnedWidth;\n  if (inputs.enabledForRows) {\n    // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n    let firstRowIndex = Math.min(getNearestIndexToRender(inputs, top, {\n      atStart: true,\n      lastPosition: inputs.rowsMeta.positions[inputs.rowsMeta.positions.length - 1] + inputs.lastRowHeight\n    }), inputs.rowsMeta.positions.length - 1);\n\n    // If any of the cells in the `firstRowIndex` is hidden due to an extended row span,\n    // Make sure the row from where the rowSpan is originated is visible.\n    const rowSpanHiddenCellOrigin = inputs.hiddenCellsOriginMap[firstRowIndex];\n    if (rowSpanHiddenCellOrigin) {\n      const minSpannedRowIndex = Math.min(...Object.values(rowSpanHiddenCellOrigin));\n      firstRowIndex = Math.min(firstRowIndex, minSpannedRowIndex);\n    }\n    const lastRowIndex = inputs.autoHeight ? firstRowIndex + inputs.rows.length : getNearestIndexToRender(inputs, top + inputs.viewportInnerHeight);\n    renderContext.firstRowIndex = firstRowIndex;\n    renderContext.lastRowIndex = lastRowIndex;\n  }\n\n  // XXX\n  // if (inputs.listView) {\n  //   return {\n  //     ...renderContext,\n  //     lastColumnIndex: 1,\n  //   };\n  // }\n\n  if (inputs.enabledForColumns) {\n    let firstColumnIndex = 0;\n    let lastColumnIndex = inputs.columnPositions.length;\n    let hasRowWithAutoHeight = false;\n    const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n      firstIndex: renderContext.firstRowIndex,\n      lastIndex: renderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: inputs.rows.length,\n      bufferBefore: scrollCache.buffer.rowBefore,\n      bufferAfter: scrollCache.buffer.rowAfter,\n      positions: inputs.rowsMeta.positions,\n      lastSize: inputs.lastRowHeight\n    });\n    if (!inputs.virtualizeColumnsWithAutoRowHeight) {\n      for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n        const row = inputs.rows[i];\n        hasRowWithAutoHeight = inputs.api.rowsMeta.rowHasAutoHeight(row.id);\n      }\n    }\n    if (!hasRowWithAutoHeight || inputs.virtualizeColumnsWithAutoRowHeight) {\n      firstColumnIndex = binarySearch(realLeft, inputs.columnPositions, {\n        atStart: true,\n        lastPosition: inputs.columnsTotalWidth\n      });\n      lastColumnIndex = binarySearch(realLeft + inputs.viewportInnerWidth, inputs.columnPositions);\n    }\n    renderContext.firstColumnIndex = firstColumnIndex;\n    renderContext.lastColumnIndex = lastColumnIndex;\n  }\n  const actualRenderContext = deriveRenderContext(inputs, renderContext, scrollCache);\n  return actualRenderContext;\n}\nfunction getNearestIndexToRender(inputs, offset, options) {\n  const lastMeasuredIndexRelativeToAllRows = inputs.api.rowsMeta.getLastMeasuredRowIndex();\n  let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;\n  if (inputs.range?.lastRowIndex && !allRowsMeasured) {\n    // Check if all rows in this page are already measured\n    allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= inputs.range.lastRowIndex;\n  }\n  const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (inputs.range?.firstRowIndex || 0), 0, inputs.rowsMeta.positions.length);\n  if (allRowsMeasured || inputs.rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset) {\n    // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n    // were measured, then use a binary search because it's faster.\n    return binarySearch(offset, inputs.rowsMeta.positions, options);\n  }\n\n  // Otherwise, use an exponential search.\n  // If rows have \"auto\" as height, their positions will be based on estimated heights.\n  // In this case, we can skip several steps until we find a position higher than the offset.\n  // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n  return exponentialSearch(offset, inputs.rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage, options);\n}\n\n/**\n * Accepts as input a raw render context (the area visible in the viewport) and adds\n * computes the actual render context based on pinned elements, buffer dimensions and\n * spanning.\n */\nfunction deriveRenderContext(inputs, nextRenderContext, scrollCache) {\n  const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstRowIndex,\n    lastIndex: nextRenderContext.lastRowIndex,\n    minFirstIndex: 0,\n    maxLastIndex: inputs.rows.length,\n    bufferBefore: scrollCache.buffer.rowBefore,\n    bufferAfter: scrollCache.buffer.rowAfter,\n    positions: inputs.rowsMeta.positions,\n    lastSize: inputs.lastRowHeight\n  });\n  const [initialFirstColumnToRender, lastColumnToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstColumnIndex,\n    lastIndex: nextRenderContext.lastColumnIndex,\n    minFirstIndex: inputs.pinnedColumns?.left.length ?? 0,\n    maxLastIndex: inputs.columns.length - (inputs.pinnedColumns?.right.length ?? 0),\n    bufferBefore: scrollCache.buffer.columnBefore,\n    bufferAfter: scrollCache.buffer.columnAfter,\n    positions: inputs.columnPositions,\n    lastSize: inputs.lastColumnWidth\n  });\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    api: inputs.api,\n    firstColumnToRender: initialFirstColumnToRender,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows: inputs.rows\n  });\n  return {\n    firstRowIndex: firstRowToRender,\n    lastRowIndex: lastRowToRender,\n    firstColumnIndex: firstColumnToRender,\n    lastColumnIndex: lastColumnToRender\n  };\n}\n/**\n * Use binary search to avoid looping through all possible positions.\n * The `options.atStart` provides the possibility to match for the first element that\n * intersects the screen, even if said element's start position is before `offset`. In\n * other words, we search for `offset + width`.\n */\nfunction binarySearch(offset, positions, options = undefined, sliceStart = 0, sliceEnd = positions.length) {\n  if (positions.length <= 0) {\n    return -1;\n  }\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const position = positions[pivot];\n  let isBefore;\n  if (options?.atStart) {\n    const width = (pivot === positions.length - 1 ? options.lastPosition : positions[pivot + 1]) - position;\n    isBefore = offset - width < position;\n  } else {\n    isBefore = offset <= position;\n  }\n  return isBefore ? binarySearch(offset, positions, options, sliceStart, pivot) : binarySearch(offset, positions, options, pivot + 1, sliceEnd);\n}\nfunction exponentialSearch(offset, positions, index, options = undefined) {\n  let interval = 1;\n  while (index < positions.length && Math.abs(positions[index]) < offset) {\n    index += interval;\n    interval *= 2;\n  }\n  return binarySearch(offset, positions, options, Math.floor(index / 2), Math.min(index, positions.length));\n}\nfunction getIndexesToRender({\n  firstIndex,\n  lastIndex,\n  bufferBefore,\n  bufferAfter,\n  minFirstIndex,\n  maxLastIndex,\n  positions,\n  lastSize\n}) {\n  const firstPosition = positions[firstIndex] - bufferBefore;\n  const lastPosition = positions[lastIndex] + bufferAfter;\n  const firstIndexPadded = binarySearch(firstPosition, positions, {\n    atStart: true,\n    lastPosition: positions[positions.length - 1] + lastSize\n  });\n  const lastIndexPadded = binarySearch(lastPosition, positions);\n  return [clamp(firstIndexPadded, minFirstIndex, maxLastIndex), clamp(lastIndexPadded, minFirstIndex, maxLastIndex)];\n}\nexport function areRenderContextsEqual(context1, context2) {\n  if (context1 === context2) {\n    return true;\n  }\n  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;\n}\nexport function computeOffsetLeft(columnPositions, renderContext, pinnedLeftLength) {\n  const left = (columnPositions[renderContext.firstColumnIndex] ?? 0) - (columnPositions[pinnedLeftLength] ?? 0);\n  return Math.abs(left);\n}\nfunction bufferForDirection(isRtl, direction, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {\n  if (isRtl) {\n    switch (direction) {\n      case ScrollDirection.LEFT:\n        direction = ScrollDirection.RIGHT;\n        break;\n      case ScrollDirection.RIGHT:\n        direction = ScrollDirection.LEFT;\n        break;\n      default:\n    }\n  }\n  switch (direction) {\n    case ScrollDirection.NONE:\n      return {\n        rowAfter: rowBufferPx,\n        rowBefore: rowBufferPx,\n        columnAfter: columnBufferPx,\n        columnBefore: columnBufferPx\n      };\n    case ScrollDirection.LEFT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: horizontalBuffer\n      };\n    case ScrollDirection.RIGHT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: horizontalBuffer,\n        columnBefore: 0\n      };\n    case ScrollDirection.UP:\n      return {\n        rowAfter: 0,\n        rowBefore: verticalBuffer,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    case ScrollDirection.DOWN:\n      return {\n        rowAfter: verticalBuffer,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    default:\n      // eslint unable to figure out enum exhaustiveness\n      throw new Error('unreachable');\n  }\n}\nfunction createScrollCache(isRtl, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {\n  return {\n    direction: ScrollDirection.NONE,\n    buffer: bufferForDirection(isRtl, ScrollDirection.NONE, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer)\n  };\n}\nfunction createRange(from, to) {\n  return Array.from({\n    length: to - from\n  }).map((_, i) => from + i);\n}\nfunction getFirstNonSpannedColumnToRender({\n  api,\n  firstColumnToRender,\n  firstRowToRender,\n  lastRowToRender,\n  visibleRows\n}) {\n  let firstNonSpannedColumnToRender = firstColumnToRender;\n  let foundStableColumn = false;\n\n  // Keep checking columns until we find one that's not spanned in any visible row\n  while (!foundStableColumn && firstNonSpannedColumnToRender >= 0) {\n    foundStableColumn = true;\n    for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n      const row = visibleRows[i];\n      if (row) {\n        const rowId = visibleRows[i].id;\n        const cellColSpanInfo = api.getCellColSpanInfo(rowId, firstNonSpannedColumnToRender);\n        if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan && cellColSpanInfo.leftVisibleCellIndex < firstNonSpannedColumnToRender) {\n          firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n          foundStableColumn = false;\n          break; // Check the new column index against the visible rows, because it might be spanned\n        }\n      }\n    }\n  }\n  return firstNonSpannedColumnToRender;\n}\nexport function roundToDecimalPlaces(value, decimals) {\n  return Math.round(value * 10 ** decimals) / 10 ** decimals;\n}","map":{"version":3,"names":["_extends","React","ReactDOM","useLazyRef","useTimeout","useEventCallback","useEnhancedEffect","platform","useRunOnce","useFirstRender","createSelector","useStore","useStoreEffect","PinnedRows","PinnedColumns","Dimensions","ScrollDirection","clamp","value","min","max","Math","MINIMUM_COLUMN_WIDTH","EMPTY_SCROLL_POSITION","top","left","EMPTY_DETAIL_PANELS","Object","freeze","Map","EMPTY_RENDER_CONTEXT","firstRowIndex","lastRowIndex","firstColumnIndex","lastColumnIndex","selectors","renderContext","state","virtualization","enabledForRows","enabledForColumns","Virtualization","initialize","initializeState","use","useVirtualization","params","enabled","isJSDOM","initialState","getters","store","api","refs","dimensions","rowHeight","columnsTotalWidth","isRtl","rowBufferPx","columnBufferPx","colspan","rows","range","columns","pinnedRows","EMPTY","pinnedColumns","minimalContentHeight","autoHeight","onWheel","onTouchMove","onRenderContextChange","onScrollChange","scrollReset","renderRow","renderInfiniteLoadingTrigger","needsHorizontalScrollbar","hasBottomPinnedRows","bottom","length","panels","setPanels","useState","setRefTick","isRenderContextReady","useRef","rowsMeta","contentHeight","scrollPosition","scroll","ignoreNextScrollEvent","previousContextScrollPosition","previousRowContext","scrollTimeout","frozenContext","undefined","scrollCache","createScrollCache","current","updateRenderContext","useCallback","nextRenderContext","areRenderContextsEqual","set","isReady","didRowsIntervalChange","triggerUpdateRenderContext","scroller","maxScrollTop","ceil","minimumSize","height","viewportOuterSize","maxScrollLeft","width","viewportInnerSize","newScroll","scrollTop","scrollLeft","dx","dy","isScrolling","direction","forDelta","NONE","rowScroll","abs","columnScroll","didCrossThreshold","didChangeDirection","shouldUpdate","LEFT","RIGHT","buffer","bufferForDirection","inputs","inputsSelector","computeRenderContext","flushSync","start","forceUpdateRenderContext","handleScroll","getOffsetTop","positions","getRows","rowParams","unstable_rowTree","baseRenderContext","isLastSection","position","isPinnedSection","rowIndexOffset","rowModels","firstRowToRender","lastRowToRender","rowIndexes","createRange","virtualRowIndex","focusedVirtualCell","rowIndex","unshift","push","rowElements","columnPositions","forEach","rowIndexInPage","id","model","minFirstColumn","maxLastColumn","right","calculateColSpan","baseRowHeight","rowHasAutoHeight","getRowHeight","isFirstVisible","isLastVisible","isLastVisibleInSection","lastIndex","isLastVisibleRowIndex","currentRenderContext","isVirtualFocusRow","isVirtualFocusColumn","offsetLeft","computeOffsetLeft","showBottomBorder","focusedColumnIndex","columnIndex","panel","get","scrollerStyle","useMemo","overflowX","overflowY","contentSize","size","flexBasis","flexShrink","scrollRestoreCallback","contentNodeRef","node","isScrollRestored","columnsTotalWidthCurrent","contentHeightCurrent","refSetter","name","tick","getContainerProps","ref","getScrollerProps","onScroll","style","role","tabIndex","isFirefox","getContentProps","getScrollbarVerticalProps","getScrollbarHorizontalProps","getScrollAreaProps","useEffect","update","values","getCellColSpanInfo","Error","getHiddenCellsOrigin","hiddenCellsOriginMap","lastRowId","at","lastColumn","leftPinnedWidth","viewportInnerWidth","viewportInnerHeight","lastRowHeight","lastColumnWidth","computedWidth","virtualizeColumnsWithAutoRowHeight","realLeft","getNearestIndexToRender","atStart","lastPosition","rowSpanHiddenCellOrigin","minSpannedRowIndex","hasRowWithAutoHeight","getIndexesToRender","firstIndex","minFirstIndex","maxLastIndex","bufferBefore","rowBefore","bufferAfter","rowAfter","lastSize","i","row","binarySearch","actualRenderContext","deriveRenderContext","offset","options","lastMeasuredIndexRelativeToAllRows","getLastMeasuredRowIndex","allRowsMeasured","Infinity","lastMeasuredIndexRelativeToCurrentPage","exponentialSearch","initialFirstColumnToRender","lastColumnToRender","columnBefore","columnAfter","firstColumnToRender","getFirstNonSpannedColumnToRender","visibleRows","sliceStart","sliceEnd","pivot","floor","isBefore","index","interval","firstPosition","firstIndexPadded","lastIndexPadded","context1","context2","pinnedLeftLength","verticalBuffer","horizontalBuffer","UP","DOWN","from","to","Array","map","_","firstNonSpannedColumnToRender","foundStableColumn","rowId","cellColSpanInfo","spannedByColSpan","leftVisibleCellIndex","roundToDecimalPlaces","decimals","round"],"sources":["/Users/abr/inventor/frontend_v2/node_modules/@mui/x-virtualizer/esm/features/virtualization.js"],"sourcesContent":["'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport useTimeout from '@mui/utils/useTimeout';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport * as platform from '@mui/x-internals/platform';\nimport { useRunOnce } from '@mui/x-internals/useRunOnce';\nimport { useFirstRender } from '@mui/x-internals/useFirstRender';\nimport { createSelector, useStore, useStoreEffect } from '@mui/x-internals/store';\nimport { PinnedRows, PinnedColumns } from \"../models/core.js\";\nimport { Dimensions } from \"./dimensions.js\";\nimport { ScrollDirection } from \"../models/index.js\";\n\n/* eslint-disable import/export, @typescript-eslint/no-redeclare */\n\nconst clamp = (value, min, max) => Math.max(min, Math.min(max, value));\nconst MINIMUM_COLUMN_WIDTH = 50;\nconst EMPTY_SCROLL_POSITION = {\n  top: 0,\n  left: 0\n};\nconst EMPTY_DETAIL_PANELS = Object.freeze(new Map());\nexport const EMPTY_RENDER_CONTEXT = {\n  firstRowIndex: 0,\n  lastRowIndex: 0,\n  firstColumnIndex: 0,\n  lastColumnIndex: 0\n};\nconst selectors = {\n  renderContext: createSelector(state => state.virtualization.renderContext),\n  enabledForRows: createSelector(state => state.virtualization.enabledForRows),\n  enabledForColumns: createSelector(state => state.virtualization.enabledForColumns)\n};\nexport const Virtualization = {\n  initialize: initializeState,\n  use: useVirtualization,\n  selectors\n};\nfunction initializeState(params) {\n  const state = {\n    virtualization: _extends({\n      enabled: !platform.isJSDOM,\n      enabledForRows: !platform.isJSDOM,\n      enabledForColumns: !platform.isJSDOM,\n      renderContext: EMPTY_RENDER_CONTEXT\n    }, params.initialState?.virtualization),\n    // FIXME: refactor once the state shape is settled\n    getters: null\n  };\n  return state;\n}\n\n/** APIs to override for colspan/rowspan */\n\nfunction useVirtualization(store, params, api) {\n  const {\n    refs,\n    dimensions: {\n      rowHeight,\n      columnsTotalWidth\n    },\n    virtualization: {\n      isRtl = false,\n      rowBufferPx = 150,\n      columnBufferPx = 150\n    },\n    colspan,\n    initialState,\n    rows,\n    range,\n    columns,\n    pinnedRows = PinnedRows.EMPTY,\n    pinnedColumns = PinnedColumns.EMPTY,\n    minimalContentHeight,\n    autoHeight,\n    onWheel,\n    onTouchMove,\n    onRenderContextChange,\n    onScrollChange,\n    scrollReset,\n    renderRow,\n    renderInfiniteLoadingTrigger\n  } = params;\n  const needsHorizontalScrollbar = useStore(store, Dimensions.selectors.needsHorizontalScrollbar);\n  const hasBottomPinnedRows = pinnedRows.bottom.length > 0;\n  const [panels, setPanels] = React.useState(EMPTY_DETAIL_PANELS);\n  const [, setRefTick] = React.useState(0);\n  const isRenderContextReady = React.useRef(false);\n  const renderContext = useStore(store, selectors.renderContext);\n  const enabledForRows = useStore(store, selectors.enabledForRows);\n  const enabledForColumns = useStore(store, selectors.enabledForColumns);\n  const rowsMeta = useStore(store, Dimensions.selectors.rowsMeta);\n  const contentHeight = useStore(store, Dimensions.selectors.contentHeight);\n\n  /*\n   * Scroll context logic\n   * ====================\n   * We only render the cells contained in the `renderContext`. However, when the user starts scrolling the grid\n   * in a direction, we want to render as many cells as possible in that direction, as to avoid presenting white\n   * areas if the user scrolls too fast/far and the viewport ends up in a region we haven't rendered yet. To render\n   * more cells, we store some offsets to add to the viewport in `scrollCache.buffer`. Those offsets make the render\n   * context wider in the direction the user is going, but also makes the buffer around the viewport `0` for the\n   * dimension (horizontal or vertical) in which the user is not scrolling. So if the normal viewport is 8 columns\n   * wide, with a 1 column buffer (10 columns total), then we want it to be exactly 8 columns wide during vertical\n   * scroll.\n   * However, we don't want the rows in the old context to re-render from e.g. 10 columns to 8 columns, because that's\n   * work that's not necessary. Thus we store the context at the start of the scroll in `frozenContext`, and the rows\n   * that are part of this old context will keep their same render context as to avoid re-rendering.\n   */\n  const scrollPosition = React.useRef(initialState?.scroll ?? EMPTY_SCROLL_POSITION);\n  const ignoreNextScrollEvent = React.useRef(false);\n  const previousContextScrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousRowContext = React.useRef(EMPTY_RENDER_CONTEXT);\n  const scrollTimeout = useTimeout();\n  const frozenContext = React.useRef(undefined);\n  const scrollCache = useLazyRef(() => createScrollCache(isRtl, rowBufferPx, columnBufferPx, rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6)).current;\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    if (!areRenderContextsEqual(nextRenderContext, store.state.virtualization.renderContext)) {\n      store.set('virtualization', _extends({}, store.state.virtualization, {\n        renderContext: nextRenderContext\n      }));\n    }\n\n    // The lazy-loading hook is listening to `renderedRowsIntervalChange`,\n    // but only does something if we already have a render context, because\n    // otherwise we would call an update directly on mount\n    const isReady = Dimensions.selectors.dimensions(store.state).isReady;\n    const didRowsIntervalChange = nextRenderContext.firstRowIndex !== previousRowContext.current.firstRowIndex || nextRenderContext.lastRowIndex !== previousRowContext.current.lastRowIndex;\n    if (isReady && didRowsIntervalChange) {\n      previousRowContext.current = nextRenderContext;\n      onRenderContextChange?.(nextRenderContext);\n    }\n    previousContextScrollPosition.current = scrollPosition.current;\n  }, [store, onRenderContextChange]);\n  const triggerUpdateRenderContext = useEventCallback(() => {\n    const scroller = refs.scroller.current;\n    if (!scroller) {\n      return undefined;\n    }\n    const dimensions = Dimensions.selectors.dimensions(store.state);\n    const maxScrollTop = Math.ceil(dimensions.minimumSize.height - dimensions.viewportOuterSize.height);\n    const maxScrollLeft = Math.ceil(dimensions.minimumSize.width - dimensions.viewportInnerSize.width);\n\n    // Clamp the scroll position to the viewport to avoid re-calculating the render context for scroll bounce\n    const newScroll = {\n      top: clamp(scroller.scrollTop, 0, maxScrollTop),\n      left: isRtl ? clamp(scroller.scrollLeft, -maxScrollLeft, 0) : clamp(scroller.scrollLeft, 0, maxScrollLeft)\n    };\n    const dx = newScroll.left - scrollPosition.current.left;\n    const dy = newScroll.top - scrollPosition.current.top;\n    const isScrolling = dx !== 0 || dy !== 0;\n    scrollPosition.current = newScroll;\n    const direction = isScrolling ? ScrollDirection.forDelta(dx, dy) : ScrollDirection.NONE;\n\n    // Since previous render, we have scrolled...\n    const rowScroll = Math.abs(scrollPosition.current.top - previousContextScrollPosition.current.top);\n    const columnScroll = Math.abs(scrollPosition.current.left - previousContextScrollPosition.current.left);\n\n    // PERF: use the computed minimum column width instead of a static one\n    const didCrossThreshold = rowScroll >= rowHeight || columnScroll >= MINIMUM_COLUMN_WIDTH;\n    const didChangeDirection = scrollCache.direction !== direction;\n    const shouldUpdate = didCrossThreshold || didChangeDirection;\n    if (!shouldUpdate) {\n      return renderContext;\n    }\n\n    // Render a new context\n\n    if (didChangeDirection) {\n      switch (direction) {\n        case ScrollDirection.NONE:\n        case ScrollDirection.LEFT:\n        case ScrollDirection.RIGHT:\n          frozenContext.current = undefined;\n          break;\n        default:\n          frozenContext.current = renderContext;\n          break;\n      }\n    }\n    scrollCache.direction = direction;\n    scrollCache.buffer = bufferForDirection(isRtl, direction, rowBufferPx, columnBufferPx, rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6);\n    const inputs = inputsSelector(store, params, api, enabledForRows, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    if (!areRenderContextsEqual(nextRenderContext, renderContext)) {\n      // Prevents batching render context changes\n      ReactDOM.flushSync(() => {\n        updateRenderContext(nextRenderContext);\n      });\n      scrollTimeout.start(1000, triggerUpdateRenderContext);\n    }\n    return nextRenderContext;\n  });\n  const forceUpdateRenderContext = useEventCallback(() => {\n    // skip update if dimensions are not ready and virtualization is enabled\n    if (!Dimensions.selectors.dimensions(store.state).isReady && (enabledForRows || enabledForColumns)) {\n      return;\n    }\n    const inputs = inputsSelector(store, params, api, enabledForRows, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    // Reset the frozen context when the render context changes, see the illustration in https://github.com/mui/mui-x/pull/12353\n    frozenContext.current = undefined;\n    updateRenderContext(nextRenderContext);\n  });\n  const handleScroll = useEventCallback(() => {\n    if (ignoreNextScrollEvent.current) {\n      ignoreNextScrollEvent.current = false;\n      return;\n    }\n    const nextRenderContext = triggerUpdateRenderContext();\n    if (nextRenderContext) {\n      onScrollChange?.(scrollPosition.current, nextRenderContext);\n    }\n  });\n  const getOffsetTop = () => {\n    return rowsMeta.positions[renderContext.firstRowIndex] ?? 0;\n  };\n\n  /**\n   * HACK: unstable_rowTree fixes the issue described below, but does it by tightly coupling this\n   * section of code to the DataGrid's rowTree model. The `unstable_rowTree` param is a temporary\n   * solution to decouple the code.\n   */\n  const getRows = (rowParams = {}, unstable_rowTree) => {\n    if (!rowParams.rows && !range) {\n      return [];\n    }\n    let baseRenderContext = renderContext;\n    if (rowParams.renderContext) {\n      baseRenderContext = rowParams.renderContext;\n      baseRenderContext.firstColumnIndex = renderContext.firstColumnIndex;\n      baseRenderContext.lastColumnIndex = renderContext.lastColumnIndex;\n    }\n    const isLastSection = !hasBottomPinnedRows && rowParams.position === undefined || hasBottomPinnedRows && rowParams.position === 'bottom';\n    const isPinnedSection = rowParams.position !== undefined;\n    let rowIndexOffset;\n    switch (rowParams.position) {\n      case 'top':\n        rowIndexOffset = 0;\n        break;\n      case 'bottom':\n        rowIndexOffset = pinnedRows.top.length + rows.length;\n        break;\n      case undefined:\n      default:\n        rowIndexOffset = pinnedRows.top.length;\n        break;\n    }\n    const rowModels = rowParams.rows ?? rows;\n    const firstRowToRender = baseRenderContext.firstRowIndex;\n    const lastRowToRender = Math.min(baseRenderContext.lastRowIndex, rowModels.length);\n    const rowIndexes = rowParams.rows ? createRange(0, rowParams.rows.length) : createRange(firstRowToRender, lastRowToRender);\n    let virtualRowIndex = -1;\n    const focusedVirtualCell = params.focusedVirtualCell?.();\n    if (!isPinnedSection && focusedVirtualCell) {\n      if (focusedVirtualCell.rowIndex < firstRowToRender) {\n        rowIndexes.unshift(focusedVirtualCell.rowIndex);\n        virtualRowIndex = focusedVirtualCell.rowIndex;\n      }\n      if (focusedVirtualCell.rowIndex > lastRowToRender) {\n        rowIndexes.push(focusedVirtualCell.rowIndex);\n        virtualRowIndex = focusedVirtualCell.rowIndex;\n      }\n    }\n    const rowElements = [];\n    const columnPositions = Dimensions.selectors.columnPositions(store.state, columns);\n    rowIndexes.forEach(rowIndexInPage => {\n      const {\n        id,\n        model\n      } = rowModels[rowIndexInPage];\n\n      // In certain cases, the state might already be updated and `params.rows` (which sets `rowModels`)\n      // contains stale data.\n      // In that case, skip any further row processing.\n      // See:\n      // - https://github.com/mui/mui-x/issues/16638\n      // - https://github.com/mui/mui-x/issues/17022\n      if (unstable_rowTree && !unstable_rowTree[id]) {\n        return;\n      }\n      const rowIndex = (range?.firstRowIndex || 0) + rowIndexOffset + rowIndexInPage;\n\n      // NOTE: This is an expensive feature, the colSpan code could be optimized.\n      if (colspan?.enabled) {\n        const minFirstColumn = pinnedColumns.left.length;\n        const maxLastColumn = columns.length - pinnedColumns.right.length;\n        api.calculateColSpan(id, minFirstColumn, maxLastColumn, columns);\n        if (pinnedColumns.left.length > 0) {\n          api.calculateColSpan(id, 0, pinnedColumns.left.length, columns);\n        }\n        if (pinnedColumns.right.length > 0) {\n          api.calculateColSpan(id, columns.length - pinnedColumns.right.length, columns.length, columns);\n        }\n      }\n      const baseRowHeight = !api.rowsMeta.rowHasAutoHeight(id) ? api.rowsMeta.getRowHeight(id) : 'auto';\n      let isFirstVisible = false;\n      if (rowParams.position === undefined) {\n        isFirstVisible = rowIndexInPage === 0;\n      }\n      let isLastVisible = false;\n      const isLastVisibleInSection = rowIndexInPage === rowModels.length - 1;\n      if (isLastSection) {\n        if (!isPinnedSection) {\n          const lastIndex = rows.length - 1;\n          const isLastVisibleRowIndex = rowIndexInPage === lastIndex;\n          if (isLastVisibleRowIndex) {\n            isLastVisible = true;\n          }\n        } else {\n          isLastVisible = isLastVisibleInSection;\n        }\n      }\n      let currentRenderContext = baseRenderContext;\n      if (frozenContext.current && rowIndexInPage >= frozenContext.current.firstRowIndex && rowIndexInPage < frozenContext.current.lastRowIndex) {\n        currentRenderContext = frozenContext.current;\n      }\n      const isVirtualFocusRow = rowIndexInPage === virtualRowIndex;\n      const isVirtualFocusColumn = focusedVirtualCell?.rowIndex === rowIndex;\n      const offsetLeft = computeOffsetLeft(columnPositions, currentRenderContext, pinnedColumns.left.length);\n      const showBottomBorder = isLastVisibleInSection && rowParams.position === 'top';\n      const firstColumnIndex = currentRenderContext.firstColumnIndex;\n      const lastColumnIndex = currentRenderContext.lastColumnIndex;\n      rowElements.push(renderRow({\n        id,\n        model,\n        rowIndex,\n        offsetLeft,\n        columnsTotalWidth,\n        baseRowHeight,\n        firstColumnIndex,\n        lastColumnIndex,\n        focusedColumnIndex: isVirtualFocusColumn ? focusedVirtualCell.columnIndex : undefined,\n        isFirstVisible,\n        isLastVisible,\n        isVirtualFocusRow,\n        showBottomBorder\n      }));\n      if (isVirtualFocusRow) {\n        return;\n      }\n      const panel = panels.get(id);\n      if (panel) {\n        rowElements.push(panel);\n      }\n      if (rowParams.position === undefined && isLastVisibleInSection) {\n        rowElements.push(renderInfiniteLoadingTrigger(id));\n      }\n    });\n    return rowElements;\n  };\n  const scrollerStyle = React.useMemo(() => ({\n    overflowX: !needsHorizontalScrollbar ? 'hidden' : undefined,\n    overflowY: autoHeight ? 'hidden' : undefined\n  }), [needsHorizontalScrollbar, autoHeight]);\n  const contentSize = React.useMemo(() => {\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      flexBasis: contentHeight,\n      flexShrink: 0\n    };\n    if (size.flexBasis === 0) {\n      size.flexBasis = minimalContentHeight; // Give room to show the overlay when there no rows.\n    }\n    return size;\n  }, [columnsTotalWidth, contentHeight, needsHorizontalScrollbar, minimalContentHeight]);\n  const scrollRestoreCallback = React.useRef(null);\n  const contentNodeRef = React.useCallback(node => {\n    if (!node) {\n      return;\n    }\n    scrollRestoreCallback.current?.(columnsTotalWidth, contentHeight);\n  }, [columnsTotalWidth, contentHeight]);\n  useEnhancedEffect(() => {\n    if (!isRenderContextReady.current) {\n      return;\n    }\n    forceUpdateRenderContext();\n  }, [enabledForColumns, enabledForRows, forceUpdateRenderContext]);\n  useEnhancedEffect(() => {\n    if (refs.scroller.current) {\n      refs.scroller.current.scrollLeft = 0;\n    }\n  }, [refs.scroller, scrollReset]);\n  useRunOnce(renderContext !== EMPTY_RENDER_CONTEXT, () => {\n    onScrollChange?.(scrollPosition.current, renderContext);\n    isRenderContextReady.current = true;\n    if (initialState?.scroll && refs.scroller.current) {\n      const scroller = refs.scroller.current;\n      const {\n        top,\n        left\n      } = initialState.scroll;\n      const isScrollRestored = {\n        top: !(top > 0),\n        left: !(left > 0)\n      };\n      if (!isScrollRestored.left && columnsTotalWidth) {\n        scroller.scrollLeft = left;\n        isScrollRestored.left = true;\n        ignoreNextScrollEvent.current = true;\n      }\n\n      // To restore the vertical scroll, we need to wait until the rows are available in the DOM (otherwise\n      // there's nowhere to scroll). We still set the scrollTop to the initial value at this point in case\n      // there already are rows rendered in the DOM, but we only confirm `isScrollRestored.top = true` in the\n      // asynchronous callback below.\n      if (!isScrollRestored.top && contentHeight) {\n        scroller.scrollTop = top;\n        ignoreNextScrollEvent.current = true;\n      }\n      if (!isScrollRestored.top || !isScrollRestored.left) {\n        scrollRestoreCallback.current = (columnsTotalWidthCurrent, contentHeightCurrent) => {\n          if (!isScrollRestored.left && columnsTotalWidthCurrent) {\n            scroller.scrollLeft = left;\n            isScrollRestored.left = true;\n            ignoreNextScrollEvent.current = true;\n          }\n          if (!isScrollRestored.top && contentHeightCurrent) {\n            scroller.scrollTop = top;\n            isScrollRestored.top = true;\n            ignoreNextScrollEvent.current = true;\n          }\n          if (isScrollRestored.left && isScrollRestored.top) {\n            scrollRestoreCallback.current = null;\n          }\n        };\n      }\n    }\n  });\n  useStoreEffect(store, Dimensions.selectors.dimensions, forceUpdateRenderContext);\n  const refSetter = name => node => {\n    if (node && refs[name].current !== node) {\n      refs[name].current = node;\n      setRefTick(tick => tick + 1);\n    }\n  };\n  const getters = {\n    setPanels,\n    getOffsetTop,\n    getRows,\n    getContainerProps: () => ({\n      ref: refSetter('container')\n    }),\n    getScrollerProps: () => ({\n      ref: refSetter('scroller'),\n      onScroll: handleScroll,\n      onWheel,\n      onTouchMove,\n      style: scrollerStyle,\n      role: 'presentation',\n      // `tabIndex` shouldn't be used along role=presentation, but it fixes a Firefox bug\n      // https://github.com/mui/mui-x/pull/13891#discussion_r1683416024\n      tabIndex: platform.isFirefox ? -1 : undefined\n    }),\n    getContentProps: () => ({\n      ref: contentNodeRef,\n      style: contentSize,\n      role: 'presentation'\n    }),\n    getScrollbarVerticalProps: () => ({\n      ref: refSetter('scrollbarVertical'),\n      scrollPosition\n    }),\n    getScrollbarHorizontalProps: () => ({\n      ref: refSetter('scrollbarHorizontal'),\n      scrollPosition\n    }),\n    getScrollAreaProps: () => ({\n      scrollPosition\n    })\n  };\n  useFirstRender(() => {\n    store.state = _extends({}, store.state, {\n      getters\n    });\n  });\n  React.useEffect(() => {\n    store.update({\n      getters\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, Object.values(getters));\n\n  /* Placeholder API functions for colspan & rowspan to re-implement */\n\n  const getCellColSpanInfo = () => {\n    throw new Error('Unimplemented: colspan feature is required');\n  };\n  const calculateColSpan = () => {\n    throw new Error('Unimplemented: colspan feature is required');\n  };\n  const getHiddenCellsOrigin = () => {\n    throw new Error('Unimplemented: rowspan feature is required');\n  };\n  return {\n    getters,\n    useVirtualization: () => useStore(store, state => state),\n    setPanels,\n    forceUpdateRenderContext,\n    getCellColSpanInfo,\n    calculateColSpan,\n    getHiddenCellsOrigin\n  };\n}\nfunction inputsSelector(store, params, api, enabledForRows, enabledForColumns) {\n  const dimensions = Dimensions.selectors.dimensions(store.state);\n  const rows = params.rows;\n  const range = params.range;\n  const columns = params.columns;\n  const hiddenCellsOriginMap = api.getHiddenCellsOrigin();\n  const lastRowId = params.rows.at(-1)?.id;\n  const lastColumn = columns.at(-1);\n  return {\n    api,\n    enabledForRows,\n    enabledForColumns,\n    autoHeight: params.autoHeight,\n    rowBufferPx: params.virtualization.rowBufferPx,\n    columnBufferPx: params.virtualization.columnBufferPx,\n    leftPinnedWidth: dimensions.leftPinnedWidth,\n    columnsTotalWidth: dimensions.columnsTotalWidth,\n    viewportInnerWidth: dimensions.viewportInnerSize.width,\n    viewportInnerHeight: dimensions.viewportInnerSize.height,\n    lastRowHeight: lastRowId !== undefined ? api.rowsMeta.getRowHeight(lastRowId) : 0,\n    lastColumnWidth: lastColumn?.computedWidth ?? 0,\n    rowsMeta: Dimensions.selectors.rowsMeta(store.state),\n    columnPositions: Dimensions.selectors.columnPositions(store.state, params.columns),\n    rows,\n    range,\n    pinnedColumns: params.pinnedColumns,\n    columns,\n    hiddenCellsOriginMap,\n    virtualizeColumnsWithAutoRowHeight: params.virtualizeColumnsWithAutoRowHeight\n  };\n}\nfunction computeRenderContext(inputs, scrollPosition, scrollCache) {\n  const renderContext = {\n    firstRowIndex: 0,\n    lastRowIndex: inputs.rows.length,\n    firstColumnIndex: 0,\n    lastColumnIndex: inputs.columns.length\n  };\n  const {\n    top,\n    left\n  } = scrollPosition;\n  const realLeft = Math.abs(left) + inputs.leftPinnedWidth;\n  if (inputs.enabledForRows) {\n    // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n    let firstRowIndex = Math.min(getNearestIndexToRender(inputs, top, {\n      atStart: true,\n      lastPosition: inputs.rowsMeta.positions[inputs.rowsMeta.positions.length - 1] + inputs.lastRowHeight\n    }), inputs.rowsMeta.positions.length - 1);\n\n    // If any of the cells in the `firstRowIndex` is hidden due to an extended row span,\n    // Make sure the row from where the rowSpan is originated is visible.\n    const rowSpanHiddenCellOrigin = inputs.hiddenCellsOriginMap[firstRowIndex];\n    if (rowSpanHiddenCellOrigin) {\n      const minSpannedRowIndex = Math.min(...Object.values(rowSpanHiddenCellOrigin));\n      firstRowIndex = Math.min(firstRowIndex, minSpannedRowIndex);\n    }\n    const lastRowIndex = inputs.autoHeight ? firstRowIndex + inputs.rows.length : getNearestIndexToRender(inputs, top + inputs.viewportInnerHeight);\n    renderContext.firstRowIndex = firstRowIndex;\n    renderContext.lastRowIndex = lastRowIndex;\n  }\n\n  // XXX\n  // if (inputs.listView) {\n  //   return {\n  //     ...renderContext,\n  //     lastColumnIndex: 1,\n  //   };\n  // }\n\n  if (inputs.enabledForColumns) {\n    let firstColumnIndex = 0;\n    let lastColumnIndex = inputs.columnPositions.length;\n    let hasRowWithAutoHeight = false;\n    const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n      firstIndex: renderContext.firstRowIndex,\n      lastIndex: renderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: inputs.rows.length,\n      bufferBefore: scrollCache.buffer.rowBefore,\n      bufferAfter: scrollCache.buffer.rowAfter,\n      positions: inputs.rowsMeta.positions,\n      lastSize: inputs.lastRowHeight\n    });\n    if (!inputs.virtualizeColumnsWithAutoRowHeight) {\n      for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n        const row = inputs.rows[i];\n        hasRowWithAutoHeight = inputs.api.rowsMeta.rowHasAutoHeight(row.id);\n      }\n    }\n    if (!hasRowWithAutoHeight || inputs.virtualizeColumnsWithAutoRowHeight) {\n      firstColumnIndex = binarySearch(realLeft, inputs.columnPositions, {\n        atStart: true,\n        lastPosition: inputs.columnsTotalWidth\n      });\n      lastColumnIndex = binarySearch(realLeft + inputs.viewportInnerWidth, inputs.columnPositions);\n    }\n    renderContext.firstColumnIndex = firstColumnIndex;\n    renderContext.lastColumnIndex = lastColumnIndex;\n  }\n  const actualRenderContext = deriveRenderContext(inputs, renderContext, scrollCache);\n  return actualRenderContext;\n}\nfunction getNearestIndexToRender(inputs, offset, options) {\n  const lastMeasuredIndexRelativeToAllRows = inputs.api.rowsMeta.getLastMeasuredRowIndex();\n  let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;\n  if (inputs.range?.lastRowIndex && !allRowsMeasured) {\n    // Check if all rows in this page are already measured\n    allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= inputs.range.lastRowIndex;\n  }\n  const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (inputs.range?.firstRowIndex || 0), 0, inputs.rowsMeta.positions.length);\n  if (allRowsMeasured || inputs.rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset) {\n    // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n    // were measured, then use a binary search because it's faster.\n    return binarySearch(offset, inputs.rowsMeta.positions, options);\n  }\n\n  // Otherwise, use an exponential search.\n  // If rows have \"auto\" as height, their positions will be based on estimated heights.\n  // In this case, we can skip several steps until we find a position higher than the offset.\n  // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n  return exponentialSearch(offset, inputs.rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage, options);\n}\n\n/**\n * Accepts as input a raw render context (the area visible in the viewport) and adds\n * computes the actual render context based on pinned elements, buffer dimensions and\n * spanning.\n */\nfunction deriveRenderContext(inputs, nextRenderContext, scrollCache) {\n  const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstRowIndex,\n    lastIndex: nextRenderContext.lastRowIndex,\n    minFirstIndex: 0,\n    maxLastIndex: inputs.rows.length,\n    bufferBefore: scrollCache.buffer.rowBefore,\n    bufferAfter: scrollCache.buffer.rowAfter,\n    positions: inputs.rowsMeta.positions,\n    lastSize: inputs.lastRowHeight\n  });\n  const [initialFirstColumnToRender, lastColumnToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstColumnIndex,\n    lastIndex: nextRenderContext.lastColumnIndex,\n    minFirstIndex: inputs.pinnedColumns?.left.length ?? 0,\n    maxLastIndex: inputs.columns.length - (inputs.pinnedColumns?.right.length ?? 0),\n    bufferBefore: scrollCache.buffer.columnBefore,\n    bufferAfter: scrollCache.buffer.columnAfter,\n    positions: inputs.columnPositions,\n    lastSize: inputs.lastColumnWidth\n  });\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    api: inputs.api,\n    firstColumnToRender: initialFirstColumnToRender,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows: inputs.rows\n  });\n  return {\n    firstRowIndex: firstRowToRender,\n    lastRowIndex: lastRowToRender,\n    firstColumnIndex: firstColumnToRender,\n    lastColumnIndex: lastColumnToRender\n  };\n}\n/**\n * Use binary search to avoid looping through all possible positions.\n * The `options.atStart` provides the possibility to match for the first element that\n * intersects the screen, even if said element's start position is before `offset`. In\n * other words, we search for `offset + width`.\n */\nfunction binarySearch(offset, positions, options = undefined, sliceStart = 0, sliceEnd = positions.length) {\n  if (positions.length <= 0) {\n    return -1;\n  }\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const position = positions[pivot];\n  let isBefore;\n  if (options?.atStart) {\n    const width = (pivot === positions.length - 1 ? options.lastPosition : positions[pivot + 1]) - position;\n    isBefore = offset - width < position;\n  } else {\n    isBefore = offset <= position;\n  }\n  return isBefore ? binarySearch(offset, positions, options, sliceStart, pivot) : binarySearch(offset, positions, options, pivot + 1, sliceEnd);\n}\nfunction exponentialSearch(offset, positions, index, options = undefined) {\n  let interval = 1;\n  while (index < positions.length && Math.abs(positions[index]) < offset) {\n    index += interval;\n    interval *= 2;\n  }\n  return binarySearch(offset, positions, options, Math.floor(index / 2), Math.min(index, positions.length));\n}\nfunction getIndexesToRender({\n  firstIndex,\n  lastIndex,\n  bufferBefore,\n  bufferAfter,\n  minFirstIndex,\n  maxLastIndex,\n  positions,\n  lastSize\n}) {\n  const firstPosition = positions[firstIndex] - bufferBefore;\n  const lastPosition = positions[lastIndex] + bufferAfter;\n  const firstIndexPadded = binarySearch(firstPosition, positions, {\n    atStart: true,\n    lastPosition: positions[positions.length - 1] + lastSize\n  });\n  const lastIndexPadded = binarySearch(lastPosition, positions);\n  return [clamp(firstIndexPadded, minFirstIndex, maxLastIndex), clamp(lastIndexPadded, minFirstIndex, maxLastIndex)];\n}\nexport function areRenderContextsEqual(context1, context2) {\n  if (context1 === context2) {\n    return true;\n  }\n  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;\n}\nexport function computeOffsetLeft(columnPositions, renderContext, pinnedLeftLength) {\n  const left = (columnPositions[renderContext.firstColumnIndex] ?? 0) - (columnPositions[pinnedLeftLength] ?? 0);\n  return Math.abs(left);\n}\nfunction bufferForDirection(isRtl, direction, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {\n  if (isRtl) {\n    switch (direction) {\n      case ScrollDirection.LEFT:\n        direction = ScrollDirection.RIGHT;\n        break;\n      case ScrollDirection.RIGHT:\n        direction = ScrollDirection.LEFT;\n        break;\n      default:\n    }\n  }\n  switch (direction) {\n    case ScrollDirection.NONE:\n      return {\n        rowAfter: rowBufferPx,\n        rowBefore: rowBufferPx,\n        columnAfter: columnBufferPx,\n        columnBefore: columnBufferPx\n      };\n    case ScrollDirection.LEFT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: horizontalBuffer\n      };\n    case ScrollDirection.RIGHT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: horizontalBuffer,\n        columnBefore: 0\n      };\n    case ScrollDirection.UP:\n      return {\n        rowAfter: 0,\n        rowBefore: verticalBuffer,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    case ScrollDirection.DOWN:\n      return {\n        rowAfter: verticalBuffer,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    default:\n      // eslint unable to figure out enum exhaustiveness\n      throw new Error('unreachable');\n  }\n}\nfunction createScrollCache(isRtl, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {\n  return {\n    direction: ScrollDirection.NONE,\n    buffer: bufferForDirection(isRtl, ScrollDirection.NONE, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer)\n  };\n}\nfunction createRange(from, to) {\n  return Array.from({\n    length: to - from\n  }).map((_, i) => from + i);\n}\nfunction getFirstNonSpannedColumnToRender({\n  api,\n  firstColumnToRender,\n  firstRowToRender,\n  lastRowToRender,\n  visibleRows\n}) {\n  let firstNonSpannedColumnToRender = firstColumnToRender;\n  let foundStableColumn = false;\n\n  // Keep checking columns until we find one that's not spanned in any visible row\n  while (!foundStableColumn && firstNonSpannedColumnToRender >= 0) {\n    foundStableColumn = true;\n    for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n      const row = visibleRows[i];\n      if (row) {\n        const rowId = visibleRows[i].id;\n        const cellColSpanInfo = api.getCellColSpanInfo(rowId, firstNonSpannedColumnToRender);\n        if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan && cellColSpanInfo.leftVisibleCellIndex < firstNonSpannedColumnToRender) {\n          firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n          foundStableColumn = false;\n          break; // Check the new column index against the visible rows, because it might be spanned\n        }\n      }\n    }\n  }\n  return firstNonSpannedColumnToRender;\n}\nexport function roundToDecimalPlaces(value, decimals) {\n  return Math.round(value * 10 ** decimals) / 10 ** decimals;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}