{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nexport let DataSourceRowsUpdateStrategy = /*#__PURE__*/function (DataSourceRowsUpdateStrategy) {\n  DataSourceRowsUpdateStrategy[\"Default\"] = \"set-new-rows\";\n  DataSourceRowsUpdateStrategy[\"LazyLoading\"] = \"replace-row-range\";\n  return DataSourceRowsUpdateStrategy;\n}({});\n\n/**\n * Provides better cache hit rate by:\n * 1. Splitting the data into smaller chunks to be stored in the cache (cache `set`)\n * 2. Merging multiple cache entries into a single response to get the required chunk (cache `get`)\n */\nexport class CacheChunkManager {\n  /**\n   * @param chunkSize The number of rows to store in each cache entry.\n   * If not set, the whole array will be stored in a single cache entry.\n   * Setting this value to smallest page size will result in better cache hit rate.\n   * Has no effect if cursor pagination is used.\n   */\n  constructor(chunkSize) {\n    this.chunkSize = chunkSize;\n  }\n  getCacheKeys = key => {\n    if (this.chunkSize < 1 || typeof key.start !== 'number') {\n      return [key];\n    }\n\n    // split the range into chunks\n    const chunkedKeys = [];\n    for (let i = key.start; i <= key.end; i += this.chunkSize) {\n      const end = Math.min(i + this.chunkSize - 1, key.end);\n      chunkedKeys.push(_extends({}, key, {\n        start: i,\n        end\n      }));\n    }\n    return chunkedKeys;\n  };\n  splitResponse = (key, response) => {\n    const cacheKeys = this.getCacheKeys(key);\n    if (cacheKeys.length === 1) {\n      return new Map([[key, response]]);\n    }\n    const responses = new Map();\n    cacheKeys.forEach(chunkKey => {\n      const isLastChunk = chunkKey.end === key.end;\n      const responseSlice = _extends({}, response, {\n        pageInfo: _extends({}, response.pageInfo, {\n          // If the original response had page info, update that information for all but last chunk and keep the original value for the last chunk\n          hasNextPage: response.pageInfo?.hasNextPage !== undefined && !isLastChunk ? true : response.pageInfo?.hasNextPage,\n          nextCursor: response.pageInfo?.nextCursor !== undefined && !isLastChunk ? response.rows[chunkKey.end + 1].id : response.pageInfo?.nextCursor\n        }),\n        rows: typeof chunkKey.start !== 'number' || typeof key.start !== 'number' ? response.rows : response.rows.slice(chunkKey.start - key.start, chunkKey.end - key.start + 1)\n      });\n      responses.set(chunkKey, responseSlice);\n    });\n    return responses;\n  };\n  static mergeResponses = responses => {\n    if (responses.length === 1) {\n      return responses[0];\n    }\n    return responses.reduce((acc, response) => ({\n      rows: [...acc.rows, ...response.rows],\n      rowCount: response.rowCount,\n      pageInfo: response.pageInfo\n    }), {\n      rows: [],\n      rowCount: 0,\n      pageInfo: {}\n    });\n  };\n}","map":{"version":3,"names":["_extends","DataSourceRowsUpdateStrategy","CacheChunkManager","constructor","chunkSize","getCacheKeys","key","start","chunkedKeys","i","end","Math","min","push","splitResponse","response","cacheKeys","length","Map","responses","forEach","chunkKey","isLastChunk","responseSlice","pageInfo","hasNextPage","undefined","nextCursor","rows","id","slice","set","mergeResponses","reduce","acc","rowCount"],"sources":["/Users/abr/inventor/frontend_v2/node_modules/@mui/x-data-grid/esm/hooks/features/dataSource/utils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nexport let DataSourceRowsUpdateStrategy = /*#__PURE__*/function (DataSourceRowsUpdateStrategy) {\n  DataSourceRowsUpdateStrategy[\"Default\"] = \"set-new-rows\";\n  DataSourceRowsUpdateStrategy[\"LazyLoading\"] = \"replace-row-range\";\n  return DataSourceRowsUpdateStrategy;\n}({});\n\n/**\n * Provides better cache hit rate by:\n * 1. Splitting the data into smaller chunks to be stored in the cache (cache `set`)\n * 2. Merging multiple cache entries into a single response to get the required chunk (cache `get`)\n */\nexport class CacheChunkManager {\n  /**\n   * @param chunkSize The number of rows to store in each cache entry.\n   * If not set, the whole array will be stored in a single cache entry.\n   * Setting this value to smallest page size will result in better cache hit rate.\n   * Has no effect if cursor pagination is used.\n   */\n  constructor(chunkSize) {\n    this.chunkSize = chunkSize;\n  }\n  getCacheKeys = key => {\n    if (this.chunkSize < 1 || typeof key.start !== 'number') {\n      return [key];\n    }\n\n    // split the range into chunks\n    const chunkedKeys = [];\n    for (let i = key.start; i <= key.end; i += this.chunkSize) {\n      const end = Math.min(i + this.chunkSize - 1, key.end);\n      chunkedKeys.push(_extends({}, key, {\n        start: i,\n        end\n      }));\n    }\n    return chunkedKeys;\n  };\n  splitResponse = (key, response) => {\n    const cacheKeys = this.getCacheKeys(key);\n    if (cacheKeys.length === 1) {\n      return new Map([[key, response]]);\n    }\n    const responses = new Map();\n    cacheKeys.forEach(chunkKey => {\n      const isLastChunk = chunkKey.end === key.end;\n      const responseSlice = _extends({}, response, {\n        pageInfo: _extends({}, response.pageInfo, {\n          // If the original response had page info, update that information for all but last chunk and keep the original value for the last chunk\n          hasNextPage: response.pageInfo?.hasNextPage !== undefined && !isLastChunk ? true : response.pageInfo?.hasNextPage,\n          nextCursor: response.pageInfo?.nextCursor !== undefined && !isLastChunk ? response.rows[chunkKey.end + 1].id : response.pageInfo?.nextCursor\n        }),\n        rows: typeof chunkKey.start !== 'number' || typeof key.start !== 'number' ? response.rows : response.rows.slice(chunkKey.start - key.start, chunkKey.end - key.start + 1)\n      });\n      responses.set(chunkKey, responseSlice);\n    });\n    return responses;\n  };\n  static mergeResponses = responses => {\n    if (responses.length === 1) {\n      return responses[0];\n    }\n    return responses.reduce((acc, response) => ({\n      rows: [...acc.rows, ...response.rows],\n      rowCount: response.rowCount,\n      pageInfo: response.pageInfo\n    }), {\n      rows: [],\n      rowCount: 0,\n      pageInfo: {}\n    });\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}