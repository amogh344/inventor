{"ast":null,"code":"import useEventCallback from '@mui/utils/useEventCallback';\n\n/* eslint-disable import/export, @typescript-eslint/no-redeclare */\n\nconst selectors = {};\nexport const Colspan = {\n  initialize: initializeState,\n  use: useColspan,\n  selectors\n};\nfunction initializeState(_params) {\n  return {\n    colspanMap: new Map()\n  };\n}\nfunction useColspan(store, params, api) {\n  const getColspan = params.colspan?.getColspan;\n  const resetColSpan = () => {\n    store.state.colspanMap = new Map();\n  };\n  const getCellColSpanInfo = (rowId, columnIndex) => {\n    return store.state.colspanMap.get(rowId)?.[columnIndex];\n  };\n\n  // Calculate `colSpan` for each cell in the row\n  const calculateColSpan = useEventCallback(getColspan ? (rowId, minFirstColumn, maxLastColumn, columns) => {\n    for (let i = minFirstColumn; i < maxLastColumn; i += 1) {\n      const cellProps = calculateCellColSpan(store.state.colspanMap, i, rowId, minFirstColumn, maxLastColumn, columns, getColspan);\n      if (cellProps.colSpan > 1) {\n        i += cellProps.colSpan - 1;\n      }\n    }\n  } : () => {});\n  api.calculateColSpan = calculateColSpan;\n  return {\n    resetColSpan,\n    getCellColSpanInfo,\n    calculateColSpan\n  };\n}\nfunction calculateCellColSpan(lookup, columnIndex, rowId, minFirstColumnIndex, maxLastColumnIndex, columns, getColspan) {\n  const columnsLength = columns.length;\n  const column = columns[columnIndex];\n  const colSpan = getColspan(rowId, column, columnIndex);\n  if (!colSpan || colSpan === 1) {\n    setCellColSpanInfo(lookup, rowId, columnIndex, {\n      spannedByColSpan: false,\n      cellProps: {\n        colSpan: 1,\n        width: column.computedWidth\n      }\n    });\n    return {\n      colSpan: 1\n    };\n  }\n  let width = column.computedWidth;\n  for (let j = 1; j < colSpan; j += 1) {\n    const nextColumnIndex = columnIndex + j;\n    // Cells should be spanned only within their column section (left-pinned, right-pinned and unpinned).\n    if (nextColumnIndex >= minFirstColumnIndex && nextColumnIndex < maxLastColumnIndex) {\n      const nextColumn = columns[nextColumnIndex];\n      width += nextColumn.computedWidth;\n      setCellColSpanInfo(lookup, rowId, columnIndex + j, {\n        spannedByColSpan: true,\n        rightVisibleCellIndex: Math.min(columnIndex + colSpan, columnsLength - 1),\n        leftVisibleCellIndex: columnIndex\n      });\n    }\n    setCellColSpanInfo(lookup, rowId, columnIndex, {\n      spannedByColSpan: false,\n      cellProps: {\n        colSpan,\n        width\n      }\n    });\n  }\n  return {\n    colSpan\n  };\n}\nfunction setCellColSpanInfo(colspanMap, rowId, columnIndex, cellColSpanInfo) {\n  let columnInfo = colspanMap.get(rowId);\n  if (!columnInfo) {\n    columnInfo = {};\n    colspanMap.set(rowId, columnInfo);\n  }\n  columnInfo[columnIndex] = cellColSpanInfo;\n}","map":{"version":3,"names":["useEventCallback","selectors","Colspan","initialize","initializeState","use","useColspan","_params","colspanMap","Map","store","params","api","getColspan","colspan","resetColSpan","state","getCellColSpanInfo","rowId","columnIndex","get","calculateColSpan","minFirstColumn","maxLastColumn","columns","i","cellProps","calculateCellColSpan","colSpan","lookup","minFirstColumnIndex","maxLastColumnIndex","columnsLength","length","column","setCellColSpanInfo","spannedByColSpan","width","computedWidth","j","nextColumnIndex","nextColumn","rightVisibleCellIndex","Math","min","leftVisibleCellIndex","cellColSpanInfo","columnInfo","set"],"sources":["/Users/abr/inventor/frontend_v2/node_modules/@mui/x-virtualizer/esm/features/colspan.js"],"sourcesContent":["import useEventCallback from '@mui/utils/useEventCallback';\n\n/* eslint-disable import/export, @typescript-eslint/no-redeclare */\n\nconst selectors = {};\nexport const Colspan = {\n  initialize: initializeState,\n  use: useColspan,\n  selectors\n};\nfunction initializeState(_params) {\n  return {\n    colspanMap: new Map()\n  };\n}\nfunction useColspan(store, params, api) {\n  const getColspan = params.colspan?.getColspan;\n  const resetColSpan = () => {\n    store.state.colspanMap = new Map();\n  };\n  const getCellColSpanInfo = (rowId, columnIndex) => {\n    return store.state.colspanMap.get(rowId)?.[columnIndex];\n  };\n\n  // Calculate `colSpan` for each cell in the row\n  const calculateColSpan = useEventCallback(getColspan ? (rowId, minFirstColumn, maxLastColumn, columns) => {\n    for (let i = minFirstColumn; i < maxLastColumn; i += 1) {\n      const cellProps = calculateCellColSpan(store.state.colspanMap, i, rowId, minFirstColumn, maxLastColumn, columns, getColspan);\n      if (cellProps.colSpan > 1) {\n        i += cellProps.colSpan - 1;\n      }\n    }\n  } : () => {});\n  api.calculateColSpan = calculateColSpan;\n  return {\n    resetColSpan,\n    getCellColSpanInfo,\n    calculateColSpan\n  };\n}\nfunction calculateCellColSpan(lookup, columnIndex, rowId, minFirstColumnIndex, maxLastColumnIndex, columns, getColspan) {\n  const columnsLength = columns.length;\n  const column = columns[columnIndex];\n  const colSpan = getColspan(rowId, column, columnIndex);\n  if (!colSpan || colSpan === 1) {\n    setCellColSpanInfo(lookup, rowId, columnIndex, {\n      spannedByColSpan: false,\n      cellProps: {\n        colSpan: 1,\n        width: column.computedWidth\n      }\n    });\n    return {\n      colSpan: 1\n    };\n  }\n  let width = column.computedWidth;\n  for (let j = 1; j < colSpan; j += 1) {\n    const nextColumnIndex = columnIndex + j;\n    // Cells should be spanned only within their column section (left-pinned, right-pinned and unpinned).\n    if (nextColumnIndex >= minFirstColumnIndex && nextColumnIndex < maxLastColumnIndex) {\n      const nextColumn = columns[nextColumnIndex];\n      width += nextColumn.computedWidth;\n      setCellColSpanInfo(lookup, rowId, columnIndex + j, {\n        spannedByColSpan: true,\n        rightVisibleCellIndex: Math.min(columnIndex + colSpan, columnsLength - 1),\n        leftVisibleCellIndex: columnIndex\n      });\n    }\n    setCellColSpanInfo(lookup, rowId, columnIndex, {\n      spannedByColSpan: false,\n      cellProps: {\n        colSpan,\n        width\n      }\n    });\n  }\n  return {\n    colSpan\n  };\n}\nfunction setCellColSpanInfo(colspanMap, rowId, columnIndex, cellColSpanInfo) {\n  let columnInfo = colspanMap.get(rowId);\n  if (!columnInfo) {\n    columnInfo = {};\n    colspanMap.set(rowId, columnInfo);\n  }\n  columnInfo[columnIndex] = cellColSpanInfo;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}